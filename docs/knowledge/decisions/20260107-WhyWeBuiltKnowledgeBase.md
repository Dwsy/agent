# Why We Built Knowledge Base

## Context (背景)
在团队协作中，我们发现以下问题：
1. 新成员需要大量时间理解项目上下文
2. 资深开发者假设新人"应该知道"某些隐性知识
3. 架构决策的背景被遗忘，只留下代码结果
4. 领域术语没有统一定义，导致沟通成本高

## Options Considered (考虑过的选项)

### Option A: 依赖代码注释
- Pros: 紧跟代码，容易维护
- Cons: 无法解释"为什么"（Why），无法跨越文件边界，新人难以发现

### Option B: 使用 Wiki 系统（如 Notion、Confluence）
- Pros: 功能强大，协作方便
- Cons: 与代码库分离，容易过时，搜索不够语义化，难以版本控制

### Option C: 基于 Markdown 的本地知识库
- Pros:
  - 紧贴代码库，版本控制自然
  - 支持代码扫描自动提取概念
  - 结构化模板强制思考"为什么"
  - 可集成到开发工作流中
- Cons: 需要手动维护索引

## The Decision (最终决策)
我们采用 **Option C: 基于 Markdown 的本地知识库**，实现方式为 `knowledge-base` 技能。

## Cognitive Alignment (认知对齐)
> 为什么这个决定对某些人来说可能反直觉？
- 我们优先考虑了**知识的可追溯性**和**与代码的紧密耦合**，而不是协作编辑的便利性。
- 行业通常做法是使用 SaaS Wiki 工具，但我们认为知识应该像代码一样管理（版本控制、PR Review）。
- 我们没有选择"自动生成文档"的工具，因为显式化知识的过程本身就是对思维的整理。

## Consequences (后果)
- **短期收益**:
  - 新成员上手时间减少 30-50%
  - 代码 Review 时更容易解释背景
  - 减少"这代码为什么要这样写"的重复讨论

- **长期维护成本**:
  - 需要团队养成持续更新的习惯
  - 需要定期运行 `scan` 和 `index` 保持同步
  - 需要在 Code Review 中检查知识库的完整性

## Next Steps
1. 在团队会议中介绍知识库系统
2. 为每个核心模块创建概念文档
3. 建立"新人必须记录困惑"的流程
4. 定期审计知识库的覆盖度